var _TOPBAR_HEIGHT = 32, _ALLOWED_VALUES_MAP = {formFactor: ["phone", "tablet"], fpsLimit: [10, 12, 15, 20, 30], ndkAbi: ["armeabi", "armeabi-v7a"], orientation: ["landscape", "portrait"], resize: ["disabled", "scale"], stderrLog: "DVIWEFS".split("")}, _common = {cachedRuntimeManifestPromise: null}, _STRING_DELIMITER = "\u0001", _TARGET_ANDROID_DP = {phone: {"long": 640, "short": 360}, tablet: {"long": 1280, "short": 800}};
function getTimeZone() {
  var a = -(new Date).getTimezoneOffset(), b = 0 <= a ? "+" : "-", a = Math.abs(a), c = String(Math.floor(a / 60)), a = String(a % 60);
  1 == c.length && (c = "0" + c);
  1 == a.length && (a = "0" + a);
  return"GMT" + b + c + ":" + a
}
function getLocale() {
  var a = window.navigator.language;
  "es-419" == a && (a = "es");
  a = a.split("-");
  return{language: a[0], country: a[1]}
}
function getCurrentZoom() {
  if (!document.body)return 1;
  var a = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  a.style.cssText = "position: absolute;visibility: hidden;";
  document.body.appendChild(a);
  var b = a.currentScale;
  document.body.removeChild(a);
  return b
}
var arcMetadata;
(function () {
  function a() {
    this.defaults_ = {allowEmptyActivityStack: !1, apkList: [], canRotate: !1, disableAutoBackButton: !1, enableAdb: !1, enableArcStrace: !1, enableExternalDirectory: !1, enableGlErrorCheck: !1, enableSynthesizeTouchEventsOnWheel: !0, formFactor: "phone", fpsLimit: 60, isSlowDebugRun: !1, jdbPort: 0, logLoadProgress: !1, minimumLaunchDelay: 0, name: "", ndkAbi: "", orientation: "portrait", packageName: "org.chromium.arc", resize: "disabled", shell: [], stderrLog: "S", useGoogleContactsSyncAdapter: !1, usePlayServices: [], sleepOnBlur: !0};
    this.data_ = {};
    this.computedValues_ = {};
    if (chrome.runtime && chrome.runtime.getManifest) {
      var a = chrome.runtime.getManifest();
      this.data_ = a.arc_metadata || {};
      this.data_.enablePlayServices && (this.data_.usePlayServices = ["ALL"], delete this.data_.enablePlayServices);
      this.validateData_();
      this.computeValues_(a)
    }
  }

  a.prototype.get = function () {
    var a = {}, c;
    for (c in this.defaults_)this.defaults_.hasOwnProperty(c) && (this.data_.hasOwnProperty(c) ? a[c] = this.data_[c] : a[c] = this.defaults_[c]);
    return this.addComputedValues_(a)
  };
  a.prototype.getValue = function (a) {
    if (this.data_.hasOwnProperty(a))return this.data_[a];
    if (this.computedValues_.hasOwnProperty(a))return this.computedValues_[a];
    if (this.defaults_.hasOwnProperty(a))return this.defaults_[a];
    throw"unknown arc_metadata param: " + a;
  };
  a.prototype.validateData_ = function () {
    for (var a in this.data_)if (this.data_.hasOwnProperty(a) && (this.defaults_.hasOwnProperty(a) ? typeof this.data_[a] !== typeof this.defaults_[a] && (console.error('Type mismatch of "' + a + '" in ARC metadata'), console.group(),
      console.error("Default type: " + typeof this.defaults_[a]), console.error("Current type: " + typeof this.data_[a]), console.groupEnd()) : console.error('Unknown property "' + a + '" in ARC metadata')), a in _ALLOWED_VALUES_MAP) {
      var c = this.data_[a], d = _ALLOWED_VALUES_MAP[a];
      -1 == d.indexOf(c) && (console.group(), console.error("Invalid value of " + a + ": " + c), console.error("It must be one of: " + d.join(", ")), console.groupEnd())
    }
  };
  a.prototype.getAndroidDensityDpi_ = function (a, c) {
    var d = [120, 160, 213, 240, 320, 400, 480, 640], e =
      160 * c;
    "tablet" == a && (e *= 0.75);
    var g = d.map(function (a) {
      return Math.abs(a - e)
    }), g = g.indexOf(Math.min.apply(Math, g));
    return d[g]
  };
  a.prototype.computeWindowSizeInChromeDips_ = function (a, c) {
    var d = this.getAndroidDensityDpi_(a, c), e = Math.ceil(_TARGET_ANDROID_DP[a].short * (d / 160) / c), g = Math.ceil(_TARGET_ANDROID_DP[a].long * (d / 160) / c);
    return{"short": e, "long": g, androidDensityDpi: d}
  };
  a.prototype.computeValues_ = function (a) {
    var c = window.devicePixelRatio / getCurrentZoom(), d = this.getValue("formFactor"), c = this.computeWindowSizeInChromeDips_(d,
      c);
    if ("landscape" == this.getValue("orientation"))var d = c.long, e = c.short; else d = c.short, e = c.long;
    this.computedValues_.width = d;
    this.computedValues_.height = e;
    this.computedValues_.androidDensityDpi = c.androidDensityDpi;
    a.oauth2 && a.oauth2.scopes && -1 != a.oauth2.scopes.indexOf("https://www.google.com/m8/feeds") && (this.data_.useGoogleContactsSyncAdapter = !0)
  };
  a.prototype.addComputedValues_ = function (a) {
    for (var c in this.computedValues_)this.computedValues_.hasOwnProperty(c) && (a[c] = this.computedValues_[c]);
    return a
  };
  arcMetadata = new a
})();
function getRuntimeManifestURL() {
  var a = chrome.runtime.getManifest()["import"][0].id;
  return chrome.runtime.getURL("/_modules/" + a + "/manifest.json")
}
function requestRuntimeManifest() {
  if (null !== _common.cachedRuntimeManifestPromise)return _common.cachedRuntimeManifestPromise;
  var a = getRuntimeManifestURL();
  _common.cachedRuntimeManifestPromise = PromiseWrap.xmlHttpRequest("GET", a).then(JSON.parse);
  return _common.cachedRuntimeManifestPromise
}
function getManifestItem(a, b, c) {
  return a.hasOwnProperty(b) ? a[b] : c
}
function getBuildTagFromManifest(a) {
  return getManifestItem(a, "arc_build_tag", "unknown")
}
function getCwsInstalled() {
  return new Promise(function (a, b) {
    requestRuntimeManifest().then(function (b) {
      "update_url"in b ? a(!0) : a(!1)
    })
  })
};
var childPlugins = [];
function ChildPlugin(a, b, c, d, e) {
  this.active = !0;
  this.args_ = b.args;
  this.backgroundPage_ = null;
  this.command_ = b.plugin;
  this.container_ = a;
  this.currentWorkingDirectory_ = b.currentworkingdirectory;
  this.envs_ = b.envs;
  this.handleExitMessage_ = c;
  this.handleStderrMessage_ = e;
  this.handleStdoutMessage_ = d;
  this.loaded_ = !1;
  this.plugin_ = null;
  this.preopened_fd_args_ = b.preopened_fd_args;
  this.preopened_fd_names_ = b.preopened_fd_names;
  this.requestId_ = b.requestid;
  this.requester_ = b.requester;
  this.timeoutId_ = null;
  this.timeout_ =
    2;
  this.create_()
}
ChildPlugin.prototype.create_ = function () {
  var a = arcMetadata.get();
  this.plugin_ = document.createElement("embed");
  this.plugin_.setAttribute("src", "arc.nmf");
  this.plugin_.setAttribute("type", "application/x-nacl");
  this.plugin_.setAttribute("plugintype", this.command_);
  this.currentWorkingDirectory_ && this.plugin_.setAttribute("current_working_directory", this.currentWorkingDirectory_);
  this.plugin_.setAttribute("args", this.args_.join(_STRING_DELIMITER));
  this.envs_ && this.plugin_.setAttribute("envs", this.envs_.join(_STRING_DELIMITER));
  this.preopened_fd_args_ && this.preopened_fd_names_ && (this.plugin_.setAttribute("preopened_fd_args", this.preopened_fd_args_.join(_STRING_DELIMITER)), this.plugin_.setAttribute("preopened_fd_names", this.preopened_fd_names_.join(_STRING_DELIMITER)));
  this.plugin_.setAttribute("requestid", this.requestId_);
  this.plugin_.setAttribute("requester", this.requester_);
  this.plugin_.setAttribute("width", 0);
  this.plugin_.setAttribute("height", 0);
  this.plugin_.setAttribute("packagename", a.packageName);
  this.plugin_.setAttribute("stderrlog",
    a.stderrLog);
  this.plugin_.setAttribute("enablearcstrace", a.enableArcStrace);
  this.plugin_.setAttribute("timezone", getTimeZone());
  var b = getLocale();
  this.plugin_.setAttribute("language", b.language);
  b.country && this.plugin_.setAttribute("country", b.country);
  "org.chromium.arc.system" == a.packageName && this.plugin_.setAttribute("enable_stdio_bridge", !0);
  console.time("ChildPlugin " + this.requester_ + ":" + this.requestId_ + ":" + this.args_[0] + "(" + this.command_ + ") Run");
  this.container_.appendChild(this.plugin_);
  this.plugin_.addEventListener("message",
    this.handleMessageEvent_.bind(this), !1);
  this.plugin_.addEventListener("crash", function (a) {
    this.postExitMessage_(this.createExitMessage_(-1), "Plugin process crashed")
  }.bind(this), !1);
  this.timeoutId_ = setTimeout(function () {
    this.timeoutId_ = null;
    if (!this.loaded_) {
      var a = this.container_;
      this.remove("timeout to spawn ChildPlugin process: " + this.args_[0] + "(" + this.command_ + "), " + this.args_.join(" "));
      32 <= this.timeout_ ? (console.error("give up to spawn ChildPlugin process."), this.postExitMessage_(this.createExitMessage_(-1))) :
        (this.timeout_ *= 2, console.log("retry to spawn with timeout " + this.timeout_ + "sec."), this.active = !0, this.container_ = a, this.create_())
    }
  }.bind(this), 1E3 * this.timeout_);
  this.backgroundPage_ = window.arc ? window.arc.backgroundPage : window
};
ChildPlugin.prototype.handleMessageEvent_ = function (a) {
  if (this.active)if (a = a.data, a.constructor == ArrayBuffer)this.backgroundPage_.crashReporter.reportCrash("minidump on " + this.command_, a); else {
    if ("jsPlugin" == a.namespace) {
      if ("loadResult" == a.command) {
        a.data.result ? (a = this.command_, 0 < this.args_.length && (a += "/" + this.args_[0]), console.log("the child process has been loaded: " + a), this.loaded_ = !0) : this.remove("Cannot load plugin process");
        return
      }
      if ("crashLogMessage" == a.command)return
    }
    "jsChildplugin" != a.namespace ?
      this.remove('Received invalid namespace message. Namespace: "' + a.namespace + '", Command: "' + a.command + '"') : "spawn" == a.command ? ChildPlugin.handleChildPluginMessage(a, this.plugin_.postMessage.bind(this.plugin_), this.handleStdoutMessage_, this.handleStderrMessage_) : "stdout" == a.command ? (a.namespace = "androidChildplugin", this.handleStdoutMessage_ && this.handleStdoutMessage_(a)) : "stderr" == a.command ? (a.namespace = "androidChildplugin", this.handleStderrMessage_ && this.handleStderrMessage_(a)) : "exit" == a.command ?
      (a.namespace = this.requester_, this.postExitMessage_(a)) : this.remove("Received unknown childplugin command: " + a.command)
  }
};
ChildPlugin.prototype.postExitMessage_ = function (a, b) {
  this.remove(b) && this.handleExitMessage_(a)
};
ChildPlugin.prototype.createExitMessage_ = function (a) {
  return{namespace: "androidChildplugin", command: "exit", data: {requestid: this.requestId_, requester: this.requester_, result: a}}
};
ChildPlugin.prototype.remove = function (a) {
  if (!this.active)return!1;
  this.active = !1;
  this.timeoutId_ && (clearTimeout(this.timeoutId_), this.timeoutId_ = null);
  console.timeEnd("ChildPlugin " + this.requester_ + ":" + this.requestId_ + ":" + this.args_[0] + "(" + this.command_ + ") Run");
  a && console.log(a);
  this.container_.removeChild(this.plugin_);
  this.plugin_ = this.container_ = null;
  childPlugins = childPlugins.filter(function (a) {
    a != this
  });
  return!0
};
ChildPlugin.handleChildPluginMessage = function (a, b, c, d) {
  "spawn" == a.command ? childPlugins.push(new ChildPlugin(document.getElementById("appdiv"), a.data, b, c, d)) : (console.log("Received unknown childplugin message: "), console.log(a))
};
var _CRASH_REPORT_SETTING_UNKNOWN = -1, _CRASH_REPORT_SETTING_DISABLED = 0, _CRASH_REPORT_SETTING_ENABLED = 1, _CRASH_REPORT_STORAGE_KEY = "crashReports", _CRASH_REPORT_STORAGE_BOOT_DELAY = 1E4, _CRASH_REPORT_MAX_AGE = 432E6;
function CrashReporter() {
  this.crashReportingEnabled_ = _CRASH_REPORT_SETTING_UNKNOWN;
  this.didReadFromStorage_ = !1;
  this.logFinishReportingCrash = !0;
  window.main && window.main.underJavascriptTestRunner && (this.logFinishReportingCrash = !1);
  this.pendingCrashReports_ = [];
  this.startTime_ = new Date
}
function showCrashInfo_(a, b) {
  a && console.log(a);
  b && console.log("crash id: " + b)
}
function crashIsTooOld_(a) {
  return!a.hasOwnProperty("crash_time") || new Date - a.crash_time > _CRASH_REPORT_MAX_AGE ? !0 : !1
}
CrashReporter.prototype.sendCrashReport_ = function (a) {
  if (this.crashReportingEnabled_ == _CRASH_REPORT_SETTING_UNKNOWN)this.pendingCrashReports_.push(a); else if (this.crashReportingEnabled_ == _CRASH_REPORT_SETTING_DISABLED)showCrashInfo_("Crash reporting not enabled in Chrome.  Please enable it."); else if (!crashIsTooOld_(a)) {
    var b = new FormData, c;
    for (c in a)"upload_file_minidump" == c ? b.append(c, new Blob([a[c]])) : b.append(c, a[c]);
    var d = new XMLHttpRequest;
    d.open("POST", "http://localhost",
      !0);
    d.onreadystatechange = function () {
      4 == d.readyState && (200 == d.status ? showCrashInfo_("Successfully uploaded crash report", d.responseText) : showCrashInfo_("Failed to report crash, status: " + d.status))
    };
    console.log("Attempting to report crash...");
    d.send(b)
  }
};
CrashReporter.prototype.sendPendingCrashReports_ = function () {
  if (this.crashReportingEnabled_ != _CRASH_REPORT_SETTING_UNKNOWN) {
    for (var a = 0; a < this.pendingCrashReports_.length; a++)this.sendCrashReport_(this.pendingCrashReports_[a]);
    this.pendingCrashReports_ = []
  }
};
CrashReporter.prototype.setCrashReportingEnabled = function (a) {
  this.crashReportingEnabled_ = a;
  this.sendPendingCrashReports_()
};
function printMiniDump_(a) {
  if (null != a) {
    var b = "";
    a = new Uint8Array(a);
    for (var c = 0; c < a.byteLength; c++)b += String.fromCharCode(a[c]);
    b = window.btoa(b);
    console.error("@@@Minidump generated@@@" + b + "@@@")
  }
}
CrashReporter.prototype.reportCrash = function (a, b, c) {
  var d = this, e = {}, g;
  console.log("Received a crash");
  return requestRuntimeManifest().then(function (f) {
    var h = getBuildTagFromManifest(f);
    g = h.replace(/^arc-runtime-/, "");
    e = {prod: "ARC", arc_app_name: arcMetadata.getValue("name"), ptime: new Date - d.startTime_, crash_time: new Date, ver: g, arc_build_tag: h, message: a, chrome_version: navigator.appVersion.match(/Chrome\/(\S*)/)[1], app_id: chrome.runtime.id, app_version: chrome.runtime.getManifest().version || "", app_package_name: arcMetadata.getValue("packageName"),
      runtime_name: getManifestItem(f, "name", "unknown"), runtime_update_url: getManifestItem(f, "update_url", "unknown")};
    if (c)for (var k in c)e[k] = c[k];
    (f = navigator.appVersion.match(/CrOS\s(\S*)\s([^)]*)/)) && (e.cros_version = f[2]);
    null != b && (e.upload_file_minidump = b);
    return PromiseWrap.getPlatformInfo()
  }).then(function (a) {
    e.arch = a.arch;
    e.nacl_arch = a.nacl_arch;
    e.os = a.os;
    return getCwsInstalled()
  }).then(function (a) {
    printMiniDump_(b, g)
    for (var c in e)"upload_file_minidump" != c && console.log(c + ": " + e[c]);
    a ? d.sendCrashReport_(e) : (showCrashInfo_("Not installed from CWS, not sending crash report."),
      printMiniDump_(b, g));
    d.logFinishReportingCrash && console.log("FINISHED REPORTING CRASH")
  })
};
CrashReporter.prototype.readFromStorage_ = function (a) {
  chrome.storage.local.get(_CRASH_REPORT_STORAGE_KEY, function (b) {
    b = b[_CRASH_REPORT_STORAGE_KEY] ? JSON.parse(b[_CRASH_REPORT_STORAGE_KEY]) : [];
    for (var c = 0; c < b.length; c++)this.pendingCrashReports_.push(b[c]);
    chrome.storage.local.remove(_CRASH_REPORT_STORAGE_KEY);
    a && a()
  }.bind(this))
};
CrashReporter.prototype.writeToStorage_ = function (a) {
  var b = {};
  b[_CRASH_REPORT_STORAGE_KEY] = JSON.stringify(this.pendingCrashReports_);
  chrome.storage.local.set(b, function () {
    chrome.runtime.lastError && (console.error("Unable to set storage for pending crash reports"), console.error("Reason: " + runtime.lastError));
    a && a()
  })
};
CrashReporter.prototype.init = function (a) {
  this.startTime_ = new Date;
  setTimeout(function () {
    this.readFromStorage_(function () {
      this.sendPendingCrashReports_();
      this.didReadFromStorage_ = !0;
      a && a()
    }.bind(this))
  }.bind(this), _CRASH_REPORT_STORAGE_BOOT_DELAY)
};
CrashReporter.prototype.shutDown = function (a) {
  this.crashReportingEnabled_ == _CRASH_REPORT_SETTING_UNKNOWN && 0 < this.pendingCrashReports_.length && (this.didReadFromStorage_ ? this.writeToStorage_(a) : this.readFromStorage_(function () {
    this.writeToStorage_(a)
  }.bind(this)))
};
var crashReporter = new CrashReporter;
function gcmServicesEnabled() {
  var a = arcMetadata.data_.usePlayServices;
  return a && 0 <= a.indexOf("gcm")
}
function GcmManager() {
}
GcmManager.prototype.handleGcmRequest = function (a, b) {
  gcmServicesEnabled() && void 0 !== chrome.gcm ? "register" == a.command ? this.register_(a.data.senderIds, b) : "unregister" == a.command ? this.unregister_(b) : "send" == a.command ? this.send_(a) : console.warn("Received unknown GCM message: " + a) : console.warn("Received GCM request while not supported")
};
GcmManager.prototype.getPlugin_ = function () {
  return appWindow && appWindow.contentWindow ? appWindow.contentWindow.plugin : null
};
GcmManager.prototype.register_ = function (a, b) {
  a ? chrome.gcm.register(a.split(","), function (a) {
    var d = {namespace: "androidGcm", data: {}};
    chrome.runtime.lastError ? (console.log("Failed to register gcm: " + chrome.runtime.lastError.message), d.command = "registerError", d.data.error = this.convertToAndroidError_(chrome.runtime.lastError.message)) : (d.command = "registerSuccess", d.data.registrationId = a);
    b.postMessage(d)
  }.bind(this)) : console.error("No senderIds", a)
};
GcmManager.prototype.unregister_ = function (a) {
  chrome.gcm.unregister(function () {
    var b = {namespace: "androidGcm", data: {}};
    chrome.runtime.lastError ? (console.error("Error happened on unregister: " + chrome.runtime.lastError.message), b.command = "unregisterError", b.data.error = this.convertToAndroidError_(chrome.runtime.lastError.message)) : b.command = "unregisterCallback";
    a.postMessage(b)
  }.bind(this))
};
GcmManager.prototype.send_ = function (a) {
  a = a.data;
  var b = {destinationId: a["google.to"], messageId: a["google.message_id"], timeToLive: a["google.ttl"], data: {}}, c;
  for (c in a)0 != c.indexOf("google") && 0 != c.indexOf("goog.") && (b.data[c] = a[c]);
  chrome.gcm.send(b, function (a) {
    if (chrome.runtime.lastError) {
      var b = this.convertToAndroidError_(chrome.runtime.lastError.message);
      this.onMessageInternal_("sendError", {errorMessage: b, messageId: a})
    }
  }.bind(this))
};
GcmManager.prototype.onMessageInternal_ = function (a, b) {
  var c = {namespace: "androidGcm", command: a, data: {}};
  b && (c.data = b);
  try {
    var d = this.getPlugin_();
    d ? d.postMessage(c) : console.log("Background mode is not yet supported")
  } catch (e) {
    console.error("Error sending the message into plugin: " + e)
  }
};
GcmManager.prototype.convertToAndroidError_ = function (a) {
  var b = {"Function was called with invalid parameters.": "INVALID_PARAMETERS", "Profile was not signed in.": "ACCOUNT_MISSING", "Manifest key was missing.": "INVALID_PARAMETERS", "Asynchronous operation is pending.": "SERVICE_NOT_AVAILABLE", "Network error occurred.": "SERVICE_NOT_AVAILABLE", "Server error occurred.": "SERVICE_NOT_AVAILABLE", "Time-to-live exceeded.": "SERVICE_NOT_AVAILABLE", "Unknown error occurred.": "SERVICE_NOT_AVAILABLE"}[a];
  if (b)return b;
  console.error("chrome.gcm: unexpected error string: " + a);
  return"SERVICE_NOT_AVAILABLE"
};
GcmManager.prototype.onMessage = function (a) {
  this.onMessageInternal_("receive", a.data)
};
GcmManager.prototype.onMessagesDeleted = function () {
  this.onMessageInternal_("deletedMessages")
};
GcmManager.prototype.onSendError = function (a) {
  this.onMessageInternal_("sendError", a)
};
var gcm = null;
gcmServicesEnabled() && chrome.gcm && (gcm = new GcmManager, chrome.gcm.onMessage.addListener(gcm.onMessage.bind(gcm)), chrome.gcm.onMessagesDeleted.addListener(gcm.onMessagesDeleted.bind(gcm)), chrome.gcm.onSendError.addListener(gcm.onSendError.bind(gcm)));
var PromiseWrap = {chooseEntry: function (a) {
  return new Promise(function (b, c) {
    chrome.fileSystem.chooseEntry(a, function (a) {
      a ? b(a) : c(Error("User cancelled."))
    })
  })
}, isFilesystemRestorable: function (a) {
  return new Promise(function (b, c) {
    chrome.fileSystem.isRestorable(a, function (d) {
      d ? b(a) : c(Error("The filesystem is not restorable."))
    })
  })
}, restoreFilesystem: function (a) {
  return new Promise(function (b, c) {
    chrome.fileSystem.restoreEntry(a, function (a) {
      a ? b(a) : c(Error(chrome.runtime.lastError.message))
    })
  })
}, getAuthToken: function (a) {
  return new Promise(function (b, c) {
    chrome.identity.getAuthToken(a, function (a) {
      chrome.runtime.lastError ? c(Error(chrome.runtime.lastError.message)) : b(a)
    })
  })
}, getPlatformInfo: function () {
  return new Promise(function (a, b) {
    chrome.runtime.getPlatformInfo(function (b) {
      a(b)
    })
  })
}, getProfileUserInfo: function () {
  return new Promise(function (a, b) {
    chrome.identity && chrome.identity.getProfileUserInfo ? chrome.identity.getProfileUserInfo(function (c) {
      chrome.runtime.lastError ? b(Error(chrome.runtime.lastError.message)) : a(c)
    }) : b(Error("chrome.identity.getProfileUserInfo is unavailable. Please make sure your Chrome is at least M37."))
  })
},
  removeCachedAuthToken: function (a) {
    return new Promise(function (b, c) {
      chrome.identity.removeCachedAuthToken(a, function () {
        chrome.runtime.lastError ? c(Error(chrome.runtime.lastError.message)) : b()
      })
    })
  }, getLocalStorageValue: function (a) {
    return new Promise(function (b, c) {
      chrome.storage.local.get(a, function (d) {
        d.hasOwnProperty(a) ? b(d[a]) : (chrome.runtime.lastError && console.error("Error on reading local storage, continue anyway: " + chrome.runtime.lastError.message), c(Error("There is no retained filesystem key.")))
      })
    })
  },
  setLocalStorageValue: function (a) {
    return new Promise(function (b, c) {
      chrome.storage.local.set(a, function (a) {
        chrome.runtime.lastError ? c(Error("Cannot save email to local storage: " + chrome.runtime.lastError.message)) : b()
      })
    })
  }, webkitRequestFileSystem: function (a, b) {
    return new Promise(function (c, d) {
      window.webkitRequestFileSystem(a, b, function (a) {
        c(a)
      }, function (a) {
        d(Error(a))
      })
    })
  }, xmlHttpRequest: function (a, b) {
    return new Promise(function (c, d) {
      var e = new XMLHttpRequest;
      e.open(a, b, !0);
      e.onreadystatechange = function () {
        try {
          4 ==
          e.readyState && (200 == e.status ? c(e.responseText) : d(Error(e.responseText)))
        } catch (a) {
          d(Error(a))
        }
      };
      e.send()
    })
  }, getDirectory: function (a, b, c) {
    return new Promise(function (d, e) {
      a.getDirectory(b, c, function (a) {
        d(a)
      }, function (a) {
        e(Error(a))
      })
    })
  }, getFile: function (a, b, c) {
    return new Promise(function (d, e) {
      a.getFile(b, c, function (a) {
        d(a)
      }, function (a) {
        e(Error(a))
      })
    })
  }, getMetadata: function (a) {
    return new Promise(function (b, c) {
      a.getMetadata(function (a) {
        b(a)
      }, function (a) {
        c(Error(a))
      })
    })
  }, mountExternalFile: function (a, b, c) {
    return new Promise(function (d, e) {
      b.postMessageAndReply_("pluginFileSystemManager", "mountExternalFile", {fileSystem: a.filesystem, fullPath: a.fullPath, writable: c}, function (a) {
        d(a)
      })
    })
  }, moveTo: function (a, b, c) {
    return new Promise(function (d, e) {
      a.moveTo(b, c, function (a) {
        d(a)
      }, function (a) {
        e(Error(a))
      })
    })
  }};
var appWindow, appLaunched = !1, dexoptPlugin, pendingUma = [], _ONINSTALL_MAX_DELAY_IN_MINUTES = 4;
function addDexoptPlugin_() {
  if (!dexoptPlugin && !appLaunched) {
    var a = arcMetadata.get().apkList, a = {requestid: 0, requester: "jsInstaller", plugin: "so_executable", args: ["dexopt", "--preopt", "/vendor/chromium/crx/" + a[a.length - 1], "$auto", "v=r,o=v,m=y,u=n"]};
    dexoptPlugin = new ChildPlugin(document.getElementById("childplugindiv"), a, function (a) {
      0 != a.data.result && console.error("Failed to dexopt on installation.");
      dexoptPlugin = null
    }, null, null)
  }
}
function needEmailToLaunch_() {
  var a = chrome.runtime.getManifest().permissions;
  return a && 0 <= a.indexOf("identity.email")
}
function maybeKillDexopt_() {
  var a = !1;
  dexoptPlugin && dexoptPlugin.active && (dexoptPlugin.remove("Dexopt plugin terminated"), a = !0);
  scheduleUma(["bool", "ArcRuntime.DexoptInterrupted", a])
}
function onLaunch(a, b) {
  function c(c) {
    var d = (new Date).getTime(), f = "runtime/gen_index.min.html", h = "";
    chrome.runtime.getManifest().hasOwnProperty("import") && (h = chrome.runtime.getManifest()["import"][0].id, f = "/_modules/" + h + "/gen_index.min.html");
    a.hasOwnProperty("windowIdOverride") && (h = a.windowIdOverride);
    appWindow = chrome.app.window.get(h);
    if (null == appWindow || a.forceWindowCreate) {
      console.time("ARC Window Popup");
      maybeKillDexopt_();
      crashReporter.init();
      var k = arcMetadata.getValue("width"), l = arcMetadata.getValue("height") +
        _TOPBAR_HEIGHT, h = {id: h, width: k, height: l, resizable: "disabled" != arcMetadata.getValue("resize"), hidden: !0, frame: "none"};
      chrome.app.window.create(f, h, function (f) {
        console.timeEnd("ARC Window Popup");
        b && b(f);
        appWindow = f;
        appWindow.contentWindow.arc = {launchArgs: a, appLaunchTime: d, backgroundPage: window, runtimeUpdatedWhileRunning: null, userEmail: c};
        appWindow.setBounds({width: k, height: l});
        appWindow.contentWindow.openParentWindow = function (a) {
          return window.open(a)
        };
        appWindow.onClosed.addListener(function () {
          appWindow =
            null;
          appLaunched = !1
        })
      })
    } else(f = appWindow.contentWindow.arc.onRelaunched) ? f(a) : console.error("onLaunched is called during initialization.")
  }

  appLaunched = !0;
  var d = arcMetadata.getValue("minimumLaunchDelay");
  0 < d ? (console.log("launchAppWindow delayed: " + d + " ms"), setTimeout(c, d)) : needEmailToLaunch_() ? PromiseWrap.getProfileUserInfo().then(function (a) {
    c(a.email)
  }, function (a) {
    console.error("Failed to get profile user info, continuing anyway: " + a.message);
    c()
  }) : c()
}
chrome.app.runtime.onLaunched.addListener(onLaunch);
function installLogic() {
  console.time("ARC onInstalled HTML5 FS init");
  window.webkitRequestFileSystem(window.PERSISTENT, 21474836480, function (a) {
    a.root.getDirectory("data", {create: !0}, function (a) {
      a.getDirectory("dalvik-cache", {create: !0}, function (a) {
        console.timeEnd("ARC onInstalled HTML5 FS init");
        addDexoptPlugin_()
      })
    })
  })
}
chrome.alarms.onAlarm.addListener(function (a) {
  "onInstallUpdate" == a.name && (appLaunched || installLogic())
});
chrome.runtime.onInstalled.addListener(function (a) {
  "install" == a.reason ? installLogic() : ("shared_module_update" == a.reason && appWindow && (appWindow.contentWindow.arc.runtimeUpdatedWhileRunning = new Date), a = Math.floor(Math.random() * _ONINSTALL_MAX_DELAY_IN_MINUTES) + 1, console.log("Delaying update install logic for " + a + " minutes"), chrome.alarms.create("onInstallUpdate", {delayInMinutes: a}))
});
function handleClipboardMessageBg_(a, b) {
  if ("jsClipboard" != a.namespace || "pushhost" != a.command && "pullhost" != a.command)return!1;
  var c = null, d = document.createElement("div");
  d.id = "clipboardHelperDiv";
  d.setAttribute("contentEditable", !0);
  d.width = d.height = 0;
  d.style.position = "absolute";
  var e = document.body, g = document.activeElement;
  e.appendChild(d);
  d.focus();
  "pushhost" == a.command ? (d.innerHTML = "" != a.data.value ? a.data.value : "\x00", c = document.execCommand("selectAll") && document.execCommand("cut")) : "pullhost" == a.command &&
    document.execCommand("paste") && (c = d.innerHTML, "\x00" == c && (c = ""));
  b({namespace: "androidClipboard", command: a.command + "response", data: {result: c}});
  e.removeChild(d);
  g && g.focus();
  return!0
}
function handleSystemMessageBg_(a) {
  return"jsSystem" == a.namespace && "relaunchApp" == a.command ? (onLaunch({forceWindowCreate: !0}), !0) : !1
}
function handleUmaMessageBg_(a) {
  return"jsUma" == a.namespace && "scheduleUma" == a.command ? (getCwsInstalled().then(function (b) {
    b && scheduleUma(a.data.uma_data, a.data.immediate)
  }), !0) : !1
}
chrome.runtime.onMessage.addListener(function (a, b, c) {
  handleClipboardMessageBg_(a, c) || handleSystemMessageBg_(a) || handleUmaMessageBg_(a) || (console.error("Unhandled message: "), console.error(a))
});
chrome.runtime.onSuspend.addListener(function () {
  reportUma()
});
function scheduleUma(a, b) {
  b = !!b;
  pendingUma = pendingUma.concat(a);
  b ? reportUma() : setTimeout(reportUma, 2E4)
}
function reportUma() {
  if (0 != pendingUma.length && !arcMetadata.getValue("isSlowDebugRun")) {
    var a = {requestid: 0, requester: "backgroundpage", plugin: "so_executable", args: ["umareporter"].concat(pendingUma)};
    new ChildPlugin(document.getElementById("childplugindiv"), a, function (a) {
    }, null, null);
    pendingUma = []
  }
};
//# sourceMappingURL=gen_main.min.js.map
